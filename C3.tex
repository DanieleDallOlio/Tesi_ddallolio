\chapter{Risultati}
\label{cap:3}
I risultati finali sono suddivisi nelle tre caratteristiche su cui è stata sviluppata l'analisi dei dati.
Saranno presentate quindi una sezione relativa ai tempi di esecuzione, una sulla memoria rss e una riguardo ai processi di lettura e scrittura. 
La descrizione delle relazioni più interessanti sarà, inoltre, accompagnata dall'utilizzo di alcuni tra i grafici formati durante l'indagine statistica.

\section{Tempi di esecuzione}
L'indagine sui tempi di esecuzione, come spiegato nel paragrafo \ref{sbsec:Te}, è stata condotta approfondendo le seguenti relazioni: i tempi di esecuzione per le regole, la durata complessiva del processo e i tempi impiegati per intervalli differenti con lo stesso range. 
Questa sezione si occuperà di presentare gli esiti finali più rilevanti di ognuno di tali aspetti.

\subsection{Tempi e regole}
Le regole previste dal procedimento hanno diviso questo ramo dell'analisi in due parti, una relativo a quei processi che non dipendono dal tipo di dati considerato e uno relativo a quelli che invece dipendono. 
Considerando le prime, è evidente dalla figura \ref{fig:Tind} come l'unico processo significativo è l'indicizzazione dello human reference per BWA, mentre le rimanenti non influiscono in alcun modo. 
In più, la differenza tra le potenze computazionali è netta già da questa figura, dato che tra l'apparecchio migliore e il peggiore vi è uno scarto di più di un'ora.
\begin{figure}[H]
\centering
\includegraphics[scale=0.46]{Tind.png}
\caption{Tempi di esecuzione per le regole indipendenti dal subset}
\label{fig:Tind}
\end{figure}
Nonostante la durata per l'indicizzazione sia già notevole, il vantaggio di questa fase  è che può essere riprodotta una sola volta per tutti i successivi lavori, a causa della sua indipendeza.

Passando alle regole dipendenti, i grafici riportati nella figura \ref{fig:Tdip} mostrano i vari andamenti per quei subset citati in precedenza con letture di range massimo 3 milioni.
Le fasi del procedimento che esauriscono più tempo sono la mappatura, che incrementa velocemente, e il riallineamento, che al contrario cresce lentamente; mentre le altre regole aumentano ma impiegano tempi sempre inferiori a 5 minuti.

\begin{figure}[H]
\centering
\subfloat[][\emph{Build BAM}]
	{\label{subfig:BB}
	\includegraphics[width=.46\textwidth]{build_bam.png}
	} \quad
\subfloat[][\emph{Mapping}]
	{\label{subfig:Map}
	\includegraphics[width=.46\textwidth]{mapping.png}
	} \\
\end{figure}
\begin{figure}[H]
\ContinuedFloat
\centering
\subfloat[][\emph{Mark Duplicates}]
	{\label{subfig:MD}
	\includegraphics[width=.46\textwidth]{mark_duplicates.png}
	} \quad
\subfloat[][\emph{Realigner}]
	{\label{subfig:Rlg}
	\includegraphics[width=.46\textwidth]{realigner.png}
	} \\
\end{figure}
\begin{figure}[H]
\ContinuedFloat
\centering
\subfloat[][\emph{Sort Picard}]
	{\label{subfig:SP}
	\includegraphics[width=.46\textwidth]{sort_picard.png}
	} 
\caption{}
\label{fig:Tdip}
\end{figure}

Ciascun gruppo di dati è stato sottoposto a regressione lineare e sono stati pure calcolati i coefficienti di correlazione, i quali hanno evidenziato come il tempo di esecuzione di ogni regola cresce linearmente rispetto al range del subset.
L'unica regola che mostra una particolarità è la fase di riallineamento(Figura\ref{subfig:Rlg}), dove soprattutto per la cpu Avoton i tempi oscillano quando i subset sono piccoli. 
In dettaglio, i coefficienti di correlazione in questa regola sono per le cpu Xeon, Atom(avoton) e Pentium n3700, rispettivamente: $0.812$, $0.656$ e $0.923$. 
Tale conseguenza è data da due fattori, dove il primo è la già citata oscillazione dei tempi per piccole variazione del range degli intervalli e il secondo è una caduta di performance dovute ad agenti scionosciuti, presumibilmente di natura tecnica.
Quest'ultimo effetto è rilevabile visibilmente per avoton(linea verde nel grafico \ref{subfig:Rlg}), dove il fenomeno di oscillazione iniziale è ben nitido.
Nonostante ciò, visto che il numero di dati che è abbondantemente superiore al centinaio, il coefficiente di Pearson determina comunque che i dati siano disposti linearmente.

E' possibile visualizzare grazie al grafico () l'andamento della macchina più performante, nominata xeond, rispetto ad un esempio di macchina tradizionale, classical, sull'intero range da 0 a 9 milioni.


\subsection{Durata complessiva}
Un interessante aspetto rilevato è stato il tempo complessivo per concludere l'intero procedimento dei passaggi per il sequenziamento che dipendono dal subset, quindi escludendo soprattuto l'indexing per bwa.
Il grafico \ref{fig:Ttot} è riferito ai subset con massimo range di 3 milioni e, anche in questo caso, la regressione lineare è confermata dai coefficienti di correlazione che superano abbondantemente lo $0.95$, per ciascuna macchina.
\begin{figure}[H]
\centering
\includegraphics[scale=0.46]{Tempi_complessivi.png}
\caption{Tempi di esecuzione per le regole indipendenti dal subset}
\label{fig:Ttot}
\end{figure}

\subsection{Tempi per stessi range}
Un approfondimento è richiesto per valutare quanto il contenuto dei dati influenza la tenuta temporale e, in conseguenza, sono state considerate varie posizioni iniziali di estrazioni dal materiale genetico grezzo, lasciando invariato la lunghezza dei dati.
Questa operazione è stata fatta, come già indicato nel paragrafo \ref{subsec:simc}, su intervalli da diecimila e centomila letture.

Sono riportati nella figura \ref{fig:Trng} due grafici rappresentativi dei due andamenti che predominano questa analisi.
\begin{figure}[H]
\centering
\subfloat[][\emph{Sorting per subset da diecimila}]
	{\label{subfig:Spdieci}
	\includegraphics[width=.46\textwidth]{sort_picard_10000.png}
	} \quad
\subfloat[][\emph{Mapping per subset da centomila}]
	{\label{subfig:Mcento}
	\includegraphics[width=.46\textwidth]{mapping_100000.png}
	} \\
\caption{}
\label{fig:Trng}
\end{figure}

Il primo caso è quello di un comportamento pressochè costante, che è il più intuitivo e che si manifesta per la maggior parte dei grafici.
Il secondo rappresenta, invece, un andamento che si allontana da una costanza ma che assume più i contorni di un fenomeno stocastico rispetto al range del subset.
Dalla seconda figura si vede proprio l'effetto di allontanamento dalla retta di fit e già si vede come questa sia comunque leggermente inclinata senza un parvente motivo.

E' possibile ipotizzare che per le regole che elaborano nello specifico le misure nei subset (la mappatura e il riallineamento), i lavori si adattino al tipo di dati e che ciò comporti un'oscillazione del tempo non ben prestabilita.

\section{Memoria RSS}
La memoria rss è stata studiata analogamente al tempo eccetto che per lo studio di una memoria complessiva dell'intero processo. 
Ciò implica che sono state analizzate in un primo momento le occupazioni della memoria per ognuna delle regole e che poi è stato tentato di definire l'andamento per diversi intervalli con stesso range. 

\subsection{RSS e regole}
Le informazioni sui vari comportamenti sono tratte dai grafici in figura \ref{fig:RSSr}, per i quali sono necessarie delle descrizioni specifiche, dato che non si ha un andamento generale. 
\begin{figure}[H]
\centering
\subfloat[][\emph{Build BAM}]
	{\label{subfig:BB_rss}
	\includegraphics[width=.46\textwidth]{Max_rss_build_bam.png}
	} \quad
\subfloat[][\emph{Mapping}]
	{\label{subfig:Map_rss}
	\includegraphics[width=.46\textwidth]{Max_rss_mapping.png}
	} \\
\end{figure}
\begin{figure}[H]
\ContinuedFloat
\centering
\subfloat[][\emph{Mark Duplicates}]
	{\label{subfig:MD_rss}
	\includegraphics[width=.46\textwidth]{Max_rss_mark_duplicates.png}
	} \quad
\subfloat[][\emph{Realigner}]
	{\label{subfig:Rlg_rss}
	\includegraphics[width=.46\textwidth]{Max_rss_realigner.png}
	} \\
\end{figure}
\begin{figure}[H]
\ContinuedFloat
\centering
\subfloat[][\emph{Sort Picard}]
	{\label{subfig:SP_rss}
	\includegraphics[width=.46\textwidth]{Max_rss_sort_picard.png}
	} 
\caption{}
\label{fig:RSSr}
\end{figure}

E' evidente che regole di marcamento dei duplicati, di riordimento per picard e di formazione del file BAM, sono pressochè adattabili ad un logaritmo. 
Ciò indica una saturazione della memoria per un certo range di subset raggiunto e questo sarà un fattore rilevante per la determinazione di un'uso efficace della parallelizzazione.

Le altre due regole che si soffermano specificatamente nei dati, la mappatura e il riallineamento, manifestano una costanza di uso della memoria ma con un notevole distinzione.
Nel caso del mapping tutte e tre le macchine lavorano alla stessa intensità, indicando una saturazione generale dell'utilizzo della memoria, mentre il riallineamento distingue una costanza singolare per ognuna delle cpu. 

Allo stesso modo che per i tempi, è stato ottenuto pure il grafico(\ref{fig:RSSind}) per le regole indipendenti dal set di dati, dove a differenza dell'impiego temporale anche l'indicizzazione dello human reference per picard consuma una parte della memoria.

\begin{figure}[H]
\centering
\includegraphics[scale=0.46]{Max_rss_ind.png}
\caption{Max RSS per le regole indipendenti dal subset}
\label{fig:RSSind}
\end{figure}

\subsection{RSS per stessi range}
Lo studio sulla memoria per intervalli diversi su stessi range ha prodotto due comportamenti caratteristici, che sono stati posti in figura \ref{fig:RSSrng}.
\begin{figure}[H]
\centering
\subfloat[][\emph{Sorting per subset da diecimila}]
	{\label{subfig:Spdiecirss}
	\includegraphics[width=.46\textwidth]{Max_rss_sort_picard_dieci.png}
	} \quad
\subfloat[][\emph{Mark duplicates per subset da centomila}]
	{\label{subfig:Mdcentorss}
	\includegraphics[width=.46\textwidth]{Max_rss_mark_duplicates_cento.png}
	} \\
\caption{}
\label{fig:RSSrng}
\end{figure}

Nella prima figura i dati oscillano leggermente rispetto ad un valore costante, ma con tali valori diversi per ciascuna cpu; mentre nella seconda, la linea su cui i dati sembrano adattarsi è la stessa per ogni apparecchio.
Ciò indica come per alcuni lavori i dispositivi si comportino allo stesso modo, o saturano completamente, e per altri la distinzione è più netta. 
In generale però, diversamente dai tempi di esecuzione, l'occupazione della memoria rss tende a non dipendere dal contenuto dei subset aventi la stessa grandezza, dato che tende a rimanere costante per ogni regola.

\section{Processi di I-O} 
Gli ultimi risultati sono stati ottenuti dall'indagine sui processi di input e output coinvolti nel completamento di ogni lavoro.
Questa sezione è suddivisa in due parti che determinano come la lettura e la scrittura sono dipendenti dal set di dati e se il contenuto di tali dati incide sull'uso della macchina per l'input ed l'output.

\subsection{I-O e regole}
Il primo esito riportato è per le regole indipendenti dai subset ed eccetto l'indicizzazione per BWA l'impatto è praticamente nullo.
\begin{figure}[H]
\centering
\subfloat[][\emph{Scrittura per regole indipendenti dai subset}]
	{\label{subfig:Iind}
	\includegraphics[width=.46\textwidth]{I_ind.png}
	} \quad
\subfloat[][\emph{Scrittura per regole indipendenti dai subset.}]
	{\label{subfig:Oind}
	\includegraphics[width=.46\textwidth]{O_ind.png}
	} \\
\caption{}
\label{fig:RSSrng}
\end{figure}
Diversamente dai tempi e dalla memoria, il lavoro di indicizzazione non è sempre costante sia nel caso di input che per quello dell'output.
Riguardo all'input, le macchine più performanti (Xeon e Pentium N3700) per la maggior parte delle volte non eseguono alcuna lettura mentre la rimanente varia imprevedibilmente per valori elevati.
Per l'output invece, l'andamento è costante per Pentium, al contrario di Xeon e Atom che similmente occupano due valori ben distinti. 


Considerando le regole che invece dipendono dal subset, sono elecanti di seguito gli andamenti dei processi per ognuna di esse.
\begin{figure}[H]
\centering
\subfloat[][\emph{Lettura per la mappatura}]
	{\label{subfig:IM}
	\includegraphics[width=.46\textwidth]{IO_Input_mapping.png}
	} \quad
\subfloat[][\emph{Scrittura per la mappatura}]
	{\label{subfig:OM}
	\includegraphics[width=.46\textwidth]{IO_Output_mapping.png}
	} \\
\caption{}
\label{fig:IOm}
\end{figure}

La fase di lettura per la mappatura sembra crescere esponenzialmente per le due macchine migliori mentre per Pentium N3700 la crescita ha un andamento che tende a saturare in maniera logaritmica. 
Gli elementi finali di Atom non seguono però un'esponenziale, suggerendo che avvenga una saturazione anche per le altre due macchine per range dei subset superiori.

La fase di scrittura, invece, mostra una andamento lineare praticamente omogeneo per tutte le macchine.  

\begin{figure}[H]
\centering
\subfloat[][\emph{Lettura per il sorting di picard}]
	{\label{subfig:ISp}
	\includegraphics[width=.46\textwidth]{IO_Input_sort_picard.png}
	} \quad
\subfloat[][\emph{Scrittura per il sorting di picard}]
	{\label{subfig:OSp}
	\includegraphics[width=.46\textwidth]{IO_Output_sort_picard.png}
	} \\
\caption{}
\label{fig:IOSp}
\end{figure}

Il lavoro di riordinamento per picard è ambiguo nella lettura perchè le macchine incrementano con traiettorie non ben definibili.
Ad esempio, per Pentium la traiettoria potrebbe essere adattata ad una retta ma un certo sotto gruppo di dati descrive una direzione diversa, vanificando l'ipotesi.

La scrittura invece inizia ad assumere contorni più chiari dopo una certa grandezza del subset, oltre il quale tende a crescere linearmente. 
Prima di raggiungere tale grandezza ogni macchina, per range diversi, mostra un avvallamento non motivabile direttamente da questo tipo di studio statistico.  

\begin{figure}[H]
\centering
\subfloat[][\emph{Lettura per la marcatura dei duplicati}]
	{\label{subfig:IMd}
	\includegraphics[width=.46\textwidth]{IO_Input_mark_duplicates.png}
	} \quad
\subfloat[][\emph{Scrittura per la marcatura dei duplicati}]
	{\label{subfig:OMd}
	\includegraphics[width=.46\textwidth]{IO_Output_mark_duplicates.png}
	} \\
\caption{}
\label{fig:IOMd}
\end{figure}

La descrizione della marcatura dei duplicati determina che la fase di lettura è coinvolta solo marginalmente, dato che esaurisce in generale meno di $2\,MB$, mentre quella di scrittura segue la stessa attitudine che il sorting per picard.
Infatti ciò è evidente soprattutto in Xeon, per cui prima di avanzare con linearità è ben delineato un ventre di una curva.  

\begin{figure}[H]
\centering
\subfloat[][\emph{Lettura per la formazione del BAM}]
	{\label{subfig:IBB}
	\includegraphics[width=.46\textwidth]{IO_Input_build_bam.png}
	} \quad
\subfloat[][\emph{Scrittura per la formazione del BAM}]
	{\label{subfig:OBB}
	\includegraphics[width=.46\textwidth]{IO_Output_build_bam.png}
	} \\
\caption{}
\label{fig:IOBB}
\end{figure}

Riguardo al passaggio per la costruzione dei file BAM, il numbero dei megabytes letti è trascurabile, al contrario che per la scrittura che segue una crescita logaritmica fino a circa 1 milione di subset, per poi cominciare a calare vistosamente.

Le ragioni di questo calo non sono spiegabili, come nei casi precedenti, semplicemente osservando tale relazione dato che sarebbe più esauriente un approfindimento sia sulle prestazione dei macchinari che sul funzionamento dell'algoritmo di formazione del BAM. 

\begin{figure}[H]
\centering
\subfloat[][\emph{Lettura per il riallineamento}]
	{\label{subfig:IR}
	\includegraphics[width=.46\textwidth]{IO_Input_realigner.png}
	} \quad
\subfloat[][\emph{Scrittura per il riallineamento}]
	{\label{subfig:OR}
	\includegraphics[width=.46\textwidth]{IO_Output_realigner.png}
	} \\
\caption{}
\label{fig:IOR}
\end{figure}

In coda, il riallineamento mostra contemporaneamente il carattere meno comprensibile per la fase di lettura e quello più nitido per la fase di scrittura.
I valori riportati nel grafico di input sono difficili da decifrare; non c'è ne un andamento univoco tra le cpu che tra i dati associati ad ognuna di esse.
Sono presenti un numero considerevole di processi che consumano una percentuale infinitesima in input che, però, sono alternati a salti elevati che tra loro non suggeriscono alcun andamento ben fissato.
Evidentemente la natura del metodo di riallineamento influenza pesantemente questa fase dei bytes, riproducendo una lettura dei bytes fortemente discontinua.

Nettamente diverso è il caso della scrittura, dove i dati tracciano una curva simile ad un logaritmo senza essere dotati di valori estranei ad essa.
In più, i vari andamenti sono ordinati rispetto alla potenza computazionale delle macchine anche se le discrepanze in questo frangente sono sottili.

\par Prima di passare al caso degli intervalli diversi con stesso intervallo, è utile sottolineare quali sono i lavori che generalemente consumano più bytes in fase di lettura e scrittura.
In entrambi i casi è il mapping ha vantare l'utilizzo maggior e all'opposto è la formazione dei BAM che necessita del minor uso delle operazioni. 
L'unico passaggio che presenta una netta inversione nell'uso di lettura e scrittura è, come si può controllare in figura \ref{fig:IOR}, il riallineamento.

\subsection{I-O per stessi range}
L'ultima valutazione è stata eseguita, allo stesso modo che per i tempi e la memoria,  su intervalli diversi con lo stesso numero di letture.
Sono stati scelti i grafici sottostanti per illustrare gli andamenti più interessanti ricavati durante le analisi.
\begin{figure}[H]
\centering
\subfloat[][\emph{Input per realigner su range diecimila}]
	{\label{subfig:IRdieci}
	\includegraphics[width=.46\textwidth]{IO_I_realigner_dieci.png}
	} \quad
\subfloat[][\emph{Output per realigner su range diecimila}]
	{\label{subfig:ORdieci}
	\includegraphics[width=.46\textwidth]{IO_O_realigner_dieci.png}
	} \\
\end{figure}
\begin{figure}[H]
\ContinuedFloat
\centering
\subfloat[][\emph{Input per mapping su range centomila}]
	{\label{subfig:MIcento}
	\includegraphics[width=.46\textwidth]{IO_I_map_cento.png}
	} \quad
\centering
\subfloat[][\emph{Output per mapping su range centomila}]
	{\label{subfig:MOcento}
	\includegraphics[width=.46\textwidth]{IO_O_map_cento.png}
	} 
\caption{}
\label{fig:IOrng}
\end{figure}

I passaggi di scrittura mostrano un andamento più omogeneo per tipo di subset, pressochè costante nel caso della figura \ref{subfig:ORdieci} e per Atom(avoton) in \ref{subfig:ORdieci}.
E' interessante notare come le macchine computino con modalità diverse e che ciò causi la perdita dell'ordine delle cpu, dalla migliore alla peggiore, che caratterizzava le analisi per i tempi e la memoria.  

Diverso è il caso della lettura che è rappresanto sia in \ref{subfig:IRdieci} che in \ref{subfig:MIcento}.  
Le varie tracce non seguono andamenti ben definiti e sono spesso accompagnati da netti salti tra le misure di lettura, i quali inducono a pensare che sia il contenuto dei subset a determinare il tipo di lettura da svolgere. 
